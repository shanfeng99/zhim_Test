C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN ..\OUTPUT\led.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE ..\USER\led.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(..\OU
                    -TPUT\led.lst) TABS(2) OBJECT(..\OUTPUT\led.obj)

line level    source

   1          #include "TP.h"
   2          #include "led.h"
   3          #include <intrins.h> 
   4          
   5          extern u8 xdata gb_TD10ms_Check1;
   6          extern u8 xdata gb_TD10ms_Check2;
   7          extern u8 xdata gb_TD10ms_Check3;
   8          extern u8 xdata gb_TD10ms_Check4;
   9          extern u8 xdata gb_TD10ms_Check5;
  10          extern u8 xdata gb_TD10ms_Check6;
  11          
  12          
  13          
  14          /*==========================================================================================
  15          函数 
  16            void WS2811_1P_Bit0()
  17          描述 
  18            指令0
  19          参数 
  20            
  21          返回  
  22          */
  23          void WS2811_1P_Bit0(){
  24   1        u8 b_Cot = 0;
  25   1        P36 = 1;
  26   1        for(b_Cot = 0;b_Cot < 1;b_Cot ++){_nop_();}
  27   1      //  _nop_();
  28   1        P36 = 0;
  29   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  30   1      }
  31          void WS2811_1P_Bit1(){
  32   1        u8 b_Cot = 0;
  33   1        P36 = 1;
  34   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  35   1        P36 = 0;  
  36   1      //  _nop_();
  37   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  38   1      }
  39          void WS2811_1P_En(){
  40   1        u8 b_Cot = 0;
  41   1        P36 = 0;
  42   1        for(b_Cot = 0;b_Cot < 150;b_Cot ++){_nop_();_nop_();}
  43   1      }
  44          /*==========================================================================================
  45          函数 
  46            void WS2811_2P_Bit0()
  47          描述 
  48            指令0
  49          参数 
  50            
  51          返回  
  52          */
  53          void WS2811_2P_Bit0(){
  54   1        u8 b_Cot = 0;
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 2   

  55   1        P37 = 1;
  56   1      //  for(b_Cot = 0;b_Cot < 1;b_Cot ++){_nop_();}
  57   1        _nop_();
  58   1        P37 = 0;  
  59   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  60   1      }
  61          void WS2811_2P_Bit1(){
  62   1        u8 b_Cot = 0;
  63   1        P37 = 1;
  64   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  65   1        P37 = 0;  
  66   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  67   1      }
  68          void WS2811_2P_En(){
  69   1        u8 b_Cot = 0;
  70   1        P37 = 0;
  71   1        for(b_Cot = 0;b_Cot < 150;b_Cot ++){_nop_();_nop_();}
  72   1      }
  73          /*==========================================================================================
  74          函数 
  75            void WS2811_3P_Bit0()
  76          描述 
  77            指令0
  78          参数 
  79            
  80          返回  
  81          */
  82          void WS2811_3P_Bit0(){
  83   1        u8 b_Cot = 0;
  84   1        P10 = 1;
  85   1      //  for(b_Cot = 0;b_Cot < 1;b_Cot ++){_nop_();}
  86   1        _nop_();
  87   1        P10 = 0;  
  88   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  89   1      }
  90          void WS2811_3P_Bit1(){
  91   1        u8 b_Cot = 0;
  92   1        P10 = 1;
  93   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  94   1        P10 = 0;  
  95   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
  96   1      }
  97          void WS2811_3P_En(){
  98   1        u8 b_Cot = 0;
  99   1        P10 = 0;
 100   1        for(b_Cot = 0;b_Cot < 150;b_Cot ++){_nop_();_nop_();}
 101   1      }
 102          /*==========================================================================================
 103          函数 
 104            void WS2811_4P_Bit0()
 105          描述 
 106            指令0
 107          参数 
 108            
 109          返回  
 110          */
 111          void WS2811_4P_Bit0(){
 112   1        u8 b_Cot = 0;
 113   1        P11 = 1;
 114   1      //  for(b_Cot = 0;b_Cot < 1;b_Cot ++){_nop_();}
 115   1        _nop_();
 116   1        P11 = 0;  
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 3   

 117   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
 118   1      }
 119          void WS2811_4P_Bit1(){
 120   1        u8 b_Cot = 0;
 121   1        P11 = 1;
 122   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
 123   1        P11 = 0;  
 124   1        for(b_Cot = 0;b_Cot < 3;b_Cot ++){_nop_();}
 125   1      }
 126          void WS2811_4P_En(){
 127   1        u8 b_Cot = 0;
 128   1        P11 = 0;
 129   1        for(b_Cot = 0;b_Cot < 150;b_Cot ++){_nop_();_nop_();}
 130   1      }
 131          
 132          /*
 133          灯带
 134          0xF000:蓝色
 135          0x0F00:红
 136          0x00F0:绿色
 137          蘑菇灯
 138          0x0000FF:红色
 139          0x00FF00:绿
 140          0xFF0000:蓝色
 141          0x00FFFF:黄色
 142          0x0061FF:橙色
 143          0xF020A0:紫色
 144          0xFFFF00:天蓝色
 145          DF3501
 146          与蘑菇灯红绿相反
 147          */
 148          
 149          /*自写灯*/
 150          u32 code gpdw_White_high[]={
 151          20, 
 152          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 153          0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,
 154          0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF
 155          };
 156          
 157          u32 code gpdw_White_low[]={
 158          20, 
 159          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 160          0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,
 161          0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333,0x333333
 162          };
 163          
 164          u32 code gpdw_skyBule_low[]={
 165          20, 
 166          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 167          0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,
 168          0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00
 169          };
 170          
 171          u32 code gpdw_dark[]={
 172          20, 
 173          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 174          0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,
 175          0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000
 176          };
 177          
 178          /*蘑菇灯*/
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 4   

 179          u32 code gpdw_Mushroom_Colour_Star[]={
 180          20, 
 181          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 182          0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x010101,0x050505,0x111111,0x222222,
 183          0x444444,0x888888,0xFFFFFF,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000
 184          };
 185          
 186          u32 code gpdw_Mushroom_Colour_White[]={
 187          20, 
 188          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 189          0x888888,0x888888,0x888888,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,
 190          0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000,0x000000
 191          };
 192          
 193          u32 code gpdw_Mushroom_Colour_Blue[]={
 194          12, 
 195          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 196          0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,
 197          0x0000FF,0x0000FF,
 198          };
 199          u32 code gpdw_Mushroom_Colour_Greed[]={
 200          12, 
 201          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 202          0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,0x00FF00,
 203          0x00FF00,0x00FF00,
 204          };
 205          u32 code gpdw_Mushroom_Colour_Red[]={
 206          12,   
 207          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 208          0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,0xFF0000,
 209          0xFF0000,0xFF0000,  
 210          };
 211          u32 code gpdw_Mushroom_Colour_Rainbow[]={
 212          6,    
 213          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 214          0xFF0000,0xFF6100,0xFFFF00,0x00FF00,0x4169E1,0xFF00FF,
 215          };
 216          u32 code gpdw_Colour_Gradual_Rainbow[]={
 217          24,   
 218          //1------2--------3--------4--------5--------6--------7--------8--------9--------10红绿蓝
 219          
 220          0x0000FF,0x0000FF,0x0000FF,0x0000FF,//
 221          0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,//
 222          0xFF0020,0xFF0020,0xFF0020,0xFF0020,//
 223          0x0000FF,0x0000FF,0x0000FF,0x0000FF,//
 224          0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,//
 225          0xFF0020,0xFF0020,0xFF0020,0xFF0020,//  
 226          };
 227          u32 code gpdw_Colour_Gradual_Rainbow1[]={
 228          24,   
 229          //1------2--------3--------4--------5--------6--------7--------8--------9--------10蓝红绿
 230          
 231          
 232          0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,//
 233          0xFF0000,0xFF0000,0xFF0000,0xFF0000,//
 234          0x20FF00,0x20FF00,0x20FF00,0x20FF00,//
 235          
 236          0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,//
 237          0xFF0000,0xFF0000,0xFF0000,0xFF0000,//
 238          0x20FF00,0x20FF00,0x20FF00,0x20FF00,//  
 239          };
 240          
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 5   

 241          u32 code gpdw_Colour_Red_Yellow_Blue[]={
 242          36, 
 243          //1------2--------3--------4--------5--------6--------7--------8--------9--------10 
 244          0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0x00FFFF,0x00FFFF,
 245          0x00FFFF,0x00FFFF,
 246          0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0x00FFFF,0x00FFFF,
 247          0x00FFFF,0x00FFFF,
 248          0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0x00FFFF,0x00FFFF,
 249          0x00FFFF,0x00FFFF,  
 250          //  0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,
 251          //  0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,
 252          //  0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,
 253          //  0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x0000FF,0x00
             -00FF,
 254          //  0x0000FF,0x0000FF,0x0000FF,0xA020F0,
 255          };
 256          u32 code gpdw_Colour_White[]={
 257          20,
 258          //1------2--------3--------4--------5--------6--------7--------8--------9--------10 
 259          0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,
 260          0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,0xFFFFFF,  
 261          };
 262          
 263          u32 code gpdw_Colour_Red_Yellow_Blue_Gradual[]={
 264          39, 
 265          //1------2--------3--------4--------5--------6--------7--------8--------9--------10 
 266          0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,0xFF00FF,
 267          0xFF40B0,0xFF8080,0xFFB040,
 268          0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,0xFFFF00,
 269          0xA0FF40,0x80FF80,0x40FFB0,
 270          0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,0x00FFFF,
 271          0x40A0FF,0x8080FF,0xB040FF,
 272          };
 273          u32 code gpdw_Mushroom_Colour_Bonus[]={
 274          12,   
 275          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 276          0xFF0000,0xFF3000,0xFF6100,0xFFA000,0xFFFF00,0x80FF00,0x00FF00,0x20A060,0x4169E1,0x803080,
 277          0xFF00FF,0xFF0080,  
 278          };
 279          //红0xFF0000,
 280          //橙0xFF6100,
 281          //黄0xFFFF00,
 282          //绿0x00FF00,
 283          //蓝0x4169E1,
 284          //紫0xFF00FF, 
 285          void WS2811_1P_1Led(u32 dw_Colour){
 286   1        u8  b_ColourBP = 0;
 287   1        u8  b_Cot = 0;
 288   1        //绿
 289   1        b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 290   1        for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 291   2          if(b_ColourBP & 0x80)WS2811_1P_Bit1();
 292   2          else WS2811_1P_Bit0();
 293   2          b_ColourBP <<= 1;
 294   2        }   
 295   1        //红
 296   1        b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 297   1        for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 298   2          if(b_ColourBP & 0x80)WS2811_1P_Bit1();
 299   2          else WS2811_1P_Bit0();
 300   2          b_ColourBP <<= 1;
 301   2        }
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 6   

 302   1        //蓝
 303   1          b_ColourBP = dw_Colour & 0x0000FF;  
 304   1        for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 305   2          if(b_ColourBP & 0x80)WS2811_1P_Bit1();
 306   2          else WS2811_1P_Bit0();
 307   2          b_ColourBP <<= 1;
 308   2        }
 309   1      }
 310          
 311          void WS2811_2P_1Led(u8 b_Mode, u32 dw_Colour){
 312   1        u8  b_ColourBP = 0;
 313   1        u8  b_Cot = 0;
 314   1        if(b_Mode == 1){
 315   2          //红
 316   2          b_ColourBP = dw_Colour & 0x0000FF;  
 317   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 318   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 319   3            else WS2811_2P_Bit0();
 320   3            b_ColourBP <<= 1;
 321   3          }
 322   2          //绿
 323   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 324   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 325   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 326   3            else WS2811_2P_Bit0();
 327   3            b_ColourBP <<= 1;
 328   3          } 
 329   2          //蓝
 330   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 331   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 332   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 333   3            else WS2811_2P_Bit0();
 334   3            b_ColourBP <<= 1;
 335   3          }
 336   2        }
 337   1        else if(b_Mode == 2){
 338   2          //红
 339   2          b_ColourBP = dw_Colour & 0x0000FF;  
 340   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 341   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 342   3            else WS2811_2P_Bit0();
 343   3            b_ColourBP <<= 1;
 344   3          }
 345   2          //蓝
 346   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 347   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 348   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 349   3            else WS2811_2P_Bit0();
 350   3            b_ColourBP <<= 1;
 351   3          } 
 352   2          //绿
 353   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 354   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 355   3            if(b_ColourBP & 0x80)WS2811_2P_Bit1();
 356   3            else WS2811_2P_Bit0();
 357   3            b_ColourBP <<= 1;
 358   3          } 
 359   2          
 360   2        }
 361   1      }
 362          
 363          
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 7   

 364          void WS2811_3P_1Led(u8 b_Mode, u32 dw_Colour){
 365   1        u8  b_ColourBP = 0;
 366   1        u8  b_Cot = 0;
 367   1        if(b_Mode == 1){
 368   2          //红
 369   2          b_ColourBP = dw_Colour & 0x0000FF;  
 370   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 371   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 372   3            else WS2811_3P_Bit0();
 373   3            b_ColourBP <<= 1;
 374   3          }
 375   2          //绿
 376   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 377   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 378   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 379   3            else WS2811_3P_Bit0();
 380   3            b_ColourBP <<= 1;
 381   3          } 
 382   2          //蓝
 383   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 384   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 385   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 386   3            else WS2811_3P_Bit0();
 387   3            b_ColourBP <<= 1;
 388   3          }
 389   2        } 
 390   1        else if(b_Mode == 2){
 391   2          //红
 392   2          b_ColourBP = dw_Colour & 0x0000FF;  
 393   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 394   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 395   3            else WS2811_3P_Bit0();
 396   3            b_ColourBP <<= 1;
 397   3          }
 398   2          //蓝
 399   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 400   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 401   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 402   3            else WS2811_3P_Bit0();
 403   3            b_ColourBP <<= 1;
 404   3          }   
 405   2          //绿
 406   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 407   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 408   3            if(b_ColourBP & 0x80)WS2811_3P_Bit1();
 409   3            else WS2811_3P_Bit0();
 410   3            b_ColourBP <<= 1;
 411   3          } 
 412   2        }
 413   1      }
 414          
 415          void WS2811_4P_1Led(u8 b_Mode, u32 dw_Colour){
 416   1        u8  b_ColourBP = 0;
 417   1        u8  b_Cot = 0;
 418   1        if(b_Mode == 1){
 419   2          //红
 420   2          b_ColourBP = dw_Colour & 0x0000FF;  
 421   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 422   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 423   3            else WS2811_4P_Bit0();
 424   3            b_ColourBP <<= 1;
 425   3          }
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 8   

 426   2          //绿
 427   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 428   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 429   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 430   3            else WS2811_4P_Bit0();
 431   3            b_ColourBP <<= 1;
 432   3          } 
 433   2          //蓝
 434   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 435   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 436   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 437   3            else WS2811_4P_Bit0();
 438   3            b_ColourBP <<= 1;
 439   3          }
 440   2        }
 441   1        else if(b_Mode == 2){
 442   2          //红
 443   2          b_ColourBP = dw_Colour & 0x0000FF;  
 444   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 445   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 446   3            else WS2811_4P_Bit0();
 447   3            b_ColourBP <<= 1;
 448   3          }
 449   2          //蓝
 450   2          b_ColourBP = (dw_Colour >> 16) & 0x0000FF;  
 451   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 452   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 453   3            else WS2811_4P_Bit0();
 454   3            b_ColourBP <<= 1;
 455   3          }   
 456   2          //绿
 457   2          b_ColourBP = (dw_Colour >> 8) & 0x0000FF; 
 458   2          for(b_Cot = 0;b_Cot < 8;b_Cot ++){
 459   3            if(b_ColourBP & 0x80)WS2811_4P_Bit1();
 460   3            else WS2811_4P_Bit0();
 461   3            b_ColourBP <<= 1;
 462   3          } 
 463   2        }
 464   1      }
 465          
 466          void WS2811_Loop_RtoL_P1(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle, u8 *b_Reset_F){  
 467   1        static u16 sw_LedCot = 0;//花式的计数
 468   1        u16 xdata w_Cot = 0;
 469   1        u16 xdata w_LedAddr = 0;
 470   1        u16 xdata w_LedMax = (*pdw_ColourStyle);//这个灯花式的 灯总数,不是灯带的灯总数
 471   1        /*花式向里面走*/
 472   1        EA = 0;
 473   1        for(w_Cot = 0;w_Cot < b_LedLength;w_Cot ++){//输出的灯光指令
 474   2          w_LedAddr = w_Cot + sw_LedCot;
 475   2          w_LedAddr %= w_LedMax;  
 476   2          WS2811_1P_1Led(*(pdw_ColourStyle + w_LedAddr + 1));
 477   2        }
 478   1        WS2811_1P_En(); 
 479   1        EA = 1;  
 480   1        if(++sw_LedCot >= w_LedMax){//本次的相对地址
 481   2          sw_LedCot = 0;
 482   2        }
 483   1      }
*** WARNING C280 IN LINE 466 OF ..\USER\led.c: 'b_FirstAddr': unreferenced local variable
*** WARNING C280 IN LINE 466 OF ..\USER\led.c: 'b_Reset_F': unreferenced local variable
 484          
 485          void WS2811_Loop_LtoR_P1(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle, u8 *b_Reset_F){
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 9   

 486   1        static u8 xdata sb_LedCot = 0;
 487   1        u8 xdata b_Cot = 0;
 488   1        u8 xdata b_LedAddr = 0;
 489   1        if((*b_Reset_F) == 1){
 490   2          (*b_Reset_F) = 0;
 491   2          sb_LedCot = b_FirstAddr - 1;        
 492   2        }
 493   1        EA = 0;
 494   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 495   2            b_LedAddr = 1 + b_Cot + sb_LedCot;
 496   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 497   3                b_LedAddr %= (u8)(*pdw_ColourStyle);
 498   3            }
 499   2            WS2811_1P_1Led(*(pdw_ColourStyle + b_LedAddr));
 500   2        }
 501   1        WS2811_1P_En(); 
 502   1        EA = 1;
 503   1        if(sb_LedCot == 0){
 504   2          sb_LedCot = (u8)(*pdw_ColourStyle) - 1;//最大值-1 因为开始值是0
 505   2        }
 506   1        else sb_LedCot --;
 507   1      }
 508          void WS2811_Loop_LtoR_P2(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 509   1        static u8 xdata sb_LedCot = 0;
 510   1        u8 xdata b_Cot = 0;
 511   1        u8 xdata b_LedAddr = 0;
 512   1        if((*b_Reset_F) == 1){
 513   2          (*b_Reset_F) = 0;
 514   2          sb_LedCot = b_FirstAddr - 1;        
 515   2        }
 516   1        EA = 0;
 517   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 518   2            b_LedAddr = 1 + b_Cot + sb_LedCot;
 519   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 520   3                b_LedAddr %= (u8)(*pdw_ColourStyle);
 521   3            }
 522   2            WS2811_2P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 523   2        }
 524   1        WS2811_2P_En(); 
 525   1        EA = 1;
 526   1        if(sb_LedCot == 0){
 527   2          sb_LedCot = (u8)(*pdw_ColourStyle) - 1;//最大值-1 因为开始值是0
 528   2        }
 529   1        else sb_LedCot --;
 530   1      }
 531          void WS2811_Loop_LtoR_P3(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 532   1        static u8 xdata sb_LedCot = 0;
 533   1        u8 xdata b_Cot = 0;
 534   1        u8 xdata b_LedAddr = 0;
 535   1        if((*b_Reset_F) == 1){
 536   2          (*b_Reset_F) = 0;
 537   2          sb_LedCot = b_FirstAddr - 1;        
 538   2        }
 539   1        EA = 0;
 540   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 541   2            b_LedAddr = 1 + b_Cot + sb_LedCot;
 542   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 543   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
 544   3            }
 545   2            WS2811_3P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 546   2        }
 547   1        WS2811_3P_En(); 
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 10  

 548   1        EA = 1;
 549   1        if(sb_LedCot == 0){
 550   2          sb_LedCot = (u8)(*pdw_ColourStyle) - 1;//最大值-1 因为开始值是0
 551   2        }
 552   1        else sb_LedCot --;
 553   1      }
 554          void WS2811_Loop_LtoR_P4(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 555   1        static u8 xdata sb_LedCot = 0;
 556   1        u8 xdata b_Cot = 0;
 557   1        u8 xdata b_LedAddr = 0;
 558   1        if((*b_Reset_F) == 1){
 559   2          (*b_Reset_F) = 0;
 560   2          sb_LedCot = b_FirstAddr - 1;        
 561   2        }
 562   1        EA = 0;
 563   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 564   2            b_LedAddr = 1 + b_Cot + sb_LedCot;
 565   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 566   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
 567   3            }
 568   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 569   2        }
 570   1        WS2811_4P_En(); 
 571   1        EA = 1;
 572   1        if(sb_LedCot == 0){
 573   2          sb_LedCot = (u8)(*pdw_ColourStyle) - 1;//最大值-1 因为开始值是0
 574   2        }
 575   1        else sb_LedCot --;
 576   1      }
 577          
 578          void WS2811_All_Gradual_P1(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 579   1        static u8 xdata sb_LedCot = 0;
 580   1        u8 xdata b_Cot = 0;
 581   1        u8 xdata b_LedCot = 0;
 582   1        u8 xdata b_LedAddr = 0;
 583   1        if((*b_Reset_F) == 1){
 584   2          (*b_Reset_F) = 0;
 585   2          sb_LedCot = 1;        
 586   2        }
 587   1        EA = 0;//中断关
 588   1        b_LedAddr = 1 + sb_LedCot;
 589   1        if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 590   2            b_LedAddr -= (u8)(*pdw_ColourStyle);
 591   2        }
 592   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 593   2          WS2811_1P_1Led(*(pdw_ColourStyle + b_LedAddr));//连续多少个灯同一个颜色
 594   2        }
 595   1        WS2811_1P_En(); 
 596   1        EA = 1;
 597   1        sb_LedCot += 1;//每次增加的灯位置
 598   1        if(sb_LedCot >= (*pdw_ColourStyle)){
 599   2          sb_LedCot = 0;//因为开始值是0
 600   2        }
 601   1      }
 602          void WS2811_All_Gradual_P2(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 603   1        static u8 xdata sb_LedCot = 0;
 604   1        u8 xdata b_Cot = 0;
 605   1        u8 xdata b_LedCot = 0;
 606   1        u8 xdata b_LedAddr = 0;
 607   1        if((*b_Reset_F) == 1){
 608   2          (*b_Reset_F) = 0;
 609   2          sb_LedCot = 1;        
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 11  

 610   2        }
 611   1        EA = 0;
 612   1        b_LedAddr = 1 + sb_LedCot;
 613   1        if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 614   2            b_LedAddr -= (u8)(*pdw_ColourStyle);
 615   2        }
 616   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 617   2          WS2811_2P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//连续多少个灯同一个颜色
 618   2        }
 619   1        WS2811_2P_En(); 
 620   1        EA = 1;
 621   1        sb_LedCot += 1;//每次增加的灯位置
 622   1        if(sb_LedCot >= (*pdw_ColourStyle)){
 623   2          sb_LedCot = 0;//因为开始值是0
 624   2        }
 625   1      }
 626          void WS2811_All_Gradual_P3(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 627   1        static u8 xdata sb_LedCot = 0;
 628   1        u8 xdata b_Cot = 0;
 629   1        u8 xdata b_LedCot = 0;
 630   1        u8 xdata b_LedAddr = 0;
 631   1        if((*b_Reset_F) == 1){
 632   2          (*b_Reset_F) = 0;
 633   2          sb_LedCot = 1;        
 634   2        }
 635   1        EA = 0;
 636   1        b_LedAddr = 1 + sb_LedCot;
 637   1        if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 638   2            b_LedAddr -= (u8)(*pdw_ColourStyle);
 639   2        }
 640   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 641   2          WS2811_3P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//连续多少个灯同一个颜色
 642   2        }
 643   1        WS2811_3P_En(); 
 644   1        EA = 1;
 645   1        sb_LedCot += 1;//每次增加的灯位置
 646   1        if(sb_LedCot >= (*pdw_ColourStyle)){
 647   2          sb_LedCot = 0;//因为开始值是0
 648   2        }
 649   1      }
 650          void WS2811_All_Gradual_P4(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 651   1        static u8 xdata sb_LedCot = 0;
 652   1        u8 xdata b_Cot = 0;
 653   1        u8 xdata b_LedCot = 0;
 654   1        u8 xdata b_LedAddr = 0;
 655   1        if((*b_Reset_F) == 1){
 656   2          (*b_Reset_F) = 0;
 657   2          sb_LedCot = 1;        
 658   2        }
 659   1        EA = 0;
 660   1        b_LedAddr = 1 + sb_LedCot;
 661   1        if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 662   2            b_LedAddr -= (u8)(*pdw_ColourStyle);
 663   2        }
 664   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 665   2          WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//连续多少个灯同一个颜色
 666   2        }
 667   1        WS2811_4P_En(); 
 668   1        EA = 1;
 669   1        sb_LedCot += 1;//每次增加的灯位置
 670   1        if(sb_LedCot >= (*pdw_ColourStyle)){
 671   2          sb_LedCot = 0;//因为开始值是0
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 12  

 672   2        }
 673   1      }
 674          u32 code gpdw_Mushroom_Blink_Red[]={
 675          10,   
 676          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 677          0xFF0000,0xBB0000,0x990000,0x770000,0x330000,0x000000,0x330000,0x770000,0x990000,0xBB0000,
 678          };
 679          u32 code gpdw_Mushroom_Blink_Orange[]={
 680          10,   
 681          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 682          0xFF6100,0xBB5000,0x994000,0x772000,0x331000,0x000000,0x331000,0x772000,0x994000,0xBB5000,  
 683          };
 684          u32 code gpdw_Mushroom_Blink_Yellow[]={
 685          10,   
 686          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 687          0xFFFF00,0xBBBB00,0x999900,0x777700,0x333300,0x000000,0x333300,0x777700,0x999900,0xBBBB00,  
 688          };
 689          u32 code gpdw_Mushroom_Blink_Greed[]={
 690          10,   
 691          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 692          0x00FF00,0x00BB00,0x009900,0x007700,0x003300,0x000000,0x003300,0x007700,0x009900,0x00BB00,  
 693          };
 694          u32 code gpdw_Mushroom_Blink_Blue[]={
 695          10,   
 696          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 697          0x4169E1,0x3060C0,0x204090,0x102050,0x081025,0x000000,0x081025,0x102050,0x204090,0x3060C0,  
 698          };
 699          u32 code gpdw_Mushroom_Blink_Purple[]={
 700          10,   
 701          //1------2--------3--------4--------5--------6--------7--------8--------9--------10
 702          0xFF00FF,0xBB00BB,0x990099,0x770077,0x330033,0x000000,0x330033,0x770077,0x990099,0xBB00BB,  
 703          };
 704          
 705          
 706          //静态显示不会变化
 707          void WS2811_Static_P1(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle){
 708   1        u8 xdata b_Cot = 0;
 709   1        u8 xdata b_LedAddr = 0;
 710   1        EA = 0;
 711   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 712   2            b_LedAddr = 1 + b_Cot + b_FirstAddr - 1;
 713   2            WS2811_1P_1Led(*(pdw_ColourStyle + b_LedAddr));
 714   2        }
 715   1        WS2811_1P_En(); 
 716   1        EA = 1;
 717   1      }
 718          void WS2811_Static_P2(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle){
 719   1        u8 xdata b_Cot = 0;
 720   1        u8 xdata b_LedAddr = 0;
 721   1        EA = 0;
 722   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 723   2            b_LedAddr = 1 + b_Cot + b_FirstAddr - 1;
 724   2            WS2811_2P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 725   2        }
 726   1        WS2811_2P_En(); 
 727   1        EA = 1;
 728   1      }
 729          void WS2811_Static_P3(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle){
 730   1        u8 xdata b_Cot = 0;
 731   1        u8 xdata b_LedAddr = 0;
 732   1        EA = 0;
 733   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 13  

 734   2            b_LedAddr = 1 + b_Cot + b_FirstAddr - 1;
 735   2            WS2811_3P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 736   2        }
 737   1        WS2811_3P_En(); 
 738   1        EA = 1;
 739   1      }
 740          void WS2811_Static_P4(u8 b_LedLength, u8 b_FirstAddr, u32 *pdw_ColourStyle){
 741   1        u8 xdata b_Cot = 0;
 742   1        u8 xdata b_LedAddr = 0;
 743   1        EA = 0;
 744   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 745   2            b_LedAddr = 1 + b_Cot + b_FirstAddr - 1;
 746   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 747   2        }
 748   1        WS2811_4P_En(); 
 749   1        EA = 1;
 750   1      }
 751          
 752          void WS2811_Loop_6Led_P1(u8 *b_Reset_F){
 753   1        static u8 sb_Led1Addr = 0;
 754   1        static u8 sb_Led2Addr = 0;
 755   1        static u8 sb_Led3Addr = 0;
 756   1        static u8 sb_Led4Addr = 0;
 757   1        static u8 sb_Led5Addr = 0;
 758   1        static u8 sb_Led6Addr = 0;
 759   1        static u8 sb_Led1Cot = 0;
 760   1        static u8 sb_Led2Cot = 0;
 761   1        static u8 sb_Led3Cot = 0;
 762   1        static u8 sb_Led4Cot = 0;
 763   1        static u8 sb_Led5Cot = 0;
 764   1        static u8 sb_Led6Cot = 0;
 765   1        static u8 sb_Led1Sum = 0;
 766   1        static u8 sb_Led2Sum = 0;
 767   1        static u8 sb_Led3Sum = 0;
 768   1        static u8 sb_Led4Sum = 0;
 769   1        static u8 sb_Led5Sum = 0;
 770   1        static u8 sb_Led6Sum = 0; 
 771   1        EA = 0;//停止中断 
 772   1        /*灯1*/
 773   1        if(gb_TD10ms_Check1){//闪烁状态
 774   2          sb_Led1Addr = 1 + sb_Led1Cot;
 775   2          if(sb_Led1Addr > 10){//数组首个是长度
 776   3            sb_Led1Addr -= 10;
 777   3          }
 778   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Red[sb_Led1Addr]);
 779   2          sb_Led1Cot += 1;//每次增加的灯位置
 780   2          if(sb_Led1Cot >= 10){
 781   3            sb_Led1Cot = 0;//因为开始值是0
 782   3            if(++sb_Led1Sum >= 2){
 783   4              sb_Led1Sum = 0;
 784   4              gb_TD10ms_Check1 = 0;
 785   4            }
 786   3          }   
 787   2        }
 788   1        else{
 789   2          sb_Led1Cot = 0;
 790   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Red[1]);
 791   2        }
 792   1        /*灯2*/
 793   1        if(gb_TD10ms_Check2){//闪烁状态
 794   2          sb_Led2Addr = 1 + sb_Led2Cot;
 795   2          if(sb_Led2Addr > 10){//数组首个是长度
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 14  

 796   3            sb_Led2Addr -= 10;
 797   3          }
 798   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Purple[sb_Led2Addr]);
 799   2          sb_Led2Cot += 1;//每次增加的灯位置
 800   2          if(sb_Led2Cot >= 10){
 801   3            sb_Led2Cot = 0;//因为开始值是0
 802   3            if(++sb_Led2Sum >= 2){
 803   4              sb_Led2Sum = 0;
 804   4              gb_TD10ms_Check2 = 0;
 805   4            }     
 806   3          }   
 807   2        }
 808   1        else{
 809   2          sb_Led2Cot = 0;
 810   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Purple[1]);
 811   2        } 
 812   1        /*灯3*/
 813   1        if(gb_TD10ms_Check3){//闪烁状态
 814   2          sb_Led3Addr = 1 + sb_Led3Cot;
 815   2          if(sb_Led3Addr > 10){//数组首个是长度
 816   3            sb_Led3Addr -= 10;
 817   3          }
 818   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Blue[sb_Led3Addr]);
 819   2          sb_Led3Cot += 1;//每次增加的灯位置
 820   2          if(sb_Led3Cot >= 10){
 821   3            sb_Led3Cot = 0;//因为开始值是0
 822   3            if(++sb_Led3Sum >= 2){
 823   4              sb_Led3Sum = 0;
 824   4              gb_TD10ms_Check3 = 0;
 825   4            }     
 826   3          }   
 827   2        }
 828   1        else{
 829   2          sb_Led3Cot = 0;
 830   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Blue[1]);
 831   2        } 
 832   1        /*灯4绿*/
 833   1        if(gb_TD10ms_Check4){//闪烁状态
 834   2          sb_Led4Addr = 1 + sb_Led4Cot;
 835   2          if(sb_Led4Addr > 10){//数组首个是长度
 836   3            sb_Led4Addr -= 10;
 837   3          }
 838   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Greed[sb_Led4Addr]);
 839   2          sb_Led4Cot += 1;//每次增加的灯位置
 840   2          if(sb_Led4Cot >= 10){
 841   3            sb_Led4Cot = 0;//因为开始值是0
 842   3            if(++sb_Led4Sum >= 2){
 843   4              sb_Led4Sum = 0;
 844   4              gb_TD10ms_Check4 = 0;
 845   4            }     
 846   3          }   
 847   2        }
 848   1        else{
 849   2          sb_Led4Cot = 0;
 850   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Greed[1]);
 851   2        }   
 852   1        /*灯5蓝*/
 853   1        if(gb_TD10ms_Check5){//闪烁状态
 854   2          sb_Led5Addr = 1 + sb_Led5Cot;
 855   2          if(sb_Led5Addr > 10){//数组首个是长度
 856   3            sb_Led5Addr -= 10;
 857   3          }
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 15  

 858   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Yellow[sb_Led5Addr]);
 859   2          sb_Led5Cot += 1;//每次增加的灯位置
 860   2          if(sb_Led5Cot >= 10){
 861   3            sb_Led5Cot = 0;//因为开始值是0
 862   3            if(++sb_Led5Sum >= 2){
 863   4              sb_Led5Sum = 0;
 864   4              gb_TD10ms_Check5 = 0;
 865   4            }     
 866   3          }   
 867   2        }
 868   1        else{
 869   2          sb_Led5Cot = 0;
 870   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Yellow[1]);
 871   2        }
 872   1        
 873   1        /*灯6紫*/
 874   1        if(gb_TD10ms_Check6){//闪烁状态
 875   2          sb_Led6Addr = 1 + sb_Led6Cot;
 876   2          if(sb_Led6Addr > 10){//数组首个是长度
 877   3            sb_Led6Addr -= 10;
 878   3          }
 879   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Orange[sb_Led6Addr]);
 880   2          sb_Led6Cot += 1;//每次增加的灯位置
 881   2          if(sb_Led6Cot >= 10){
 882   3            sb_Led6Cot = 0;//因为开始值是0
 883   3            if(++sb_Led6Sum >= 2){
 884   4              sb_Led6Sum = 0;
 885   4              gb_TD10ms_Check6 = 0;
 886   4            }     
 887   3          }   
 888   2        }
 889   1        else{
 890   2          sb_Led6Cot = 0;
 891   2          WS2811_1P_1Led(gpdw_Mushroom_Blink_Orange[1]);
 892   2        } 
 893   1        WS2811_1P_En(); 
 894   1        EA = 1; 
 895   1      }
*** WARNING C280 IN LINE 752 OF ..\USER\led.c: 'b_Reset_F': unreferenced local variable
 896          
 897          void WS2811_Loop_kai_P4(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 898   1        static u8 xdata sb_LedCot = 0;
 899   1        u8 xdata b_Cot = 0;
 900   1        u8 xdata b_LedAddr = 0;
 901   1        if((*b_Reset_F) == 1){
 902   2          (*b_Reset_F) = 0;
 903   2          sb_LedCot = 0;        
 904   2        }
 905   1        EA = 0;
 906   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){
 907   2            b_LedAddr = 1 + b_Cot;
 908   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度
 909   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
 910   3            }
 911   2            if((b_Cot+1) < sb_LedCot)
 912   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));
 913   2            else WS2811_4P_1Led(2, 0x000000);
 914   2        }
 915   1        WS2811_4P_En(); 
 916   1        EA = 1;
 917   1        if(sb_LedCot == b_LedLength){
 918   2          sb_LedCot = 0;//最大值-1 因为开始值是0
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 16  

 919   2        }
 920   1        else sb_LedCot ++;
 921   1      }
 922          
 923          
 924          /*
 925          void WS2811_Loop_guan_P4(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F)
 926          效果：灯光逐个变暗，调用一次灭一个灯
 927          b_LedLength：灯光长度
 928          pdw_ColourStyle：灯光效果颜色
 929          b_Reset_F：复位；置1复位（复位后再次调用从全亮开始）
 930          */
 931          void WS2811_Loop_guan_P4(u8 b_LedLength, u32 *pdw_ColourStyle, u8 *b_Reset_F){
 932   1        static u8 xdata sb_LedCot = 0;
 933   1        u8 xdata b_Cot = 0;
 934   1        u8 xdata b_LedAddr = 0;
 935   1        if((*b_Reset_F) == 1){//b_Reset_F置1复位
 936   2          (*b_Reset_F) = 0;
 937   2          sb_LedCot = 0;        
 938   2        }
 939   1        EA = 0;         //锁住中断，防止中断打乱灯光信号数据发送
 940   1        for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){//循环b_LedLength次，即灯光效果长度次
 941   2            b_LedAddr = 1 + b_Cot;
 942   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度，若长于数组则回到数组第一位
 943   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
 944   3            }
 945   2            if((b_Cot+1) < sb_LedCot)//函数内循环次数小于函数运行次数发送灭灯信号
 946   2              WS2811_4P_1Led(2, 0x000000);      
 947   2            else WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//其他亮灯
 948   2        }
 949   1        WS2811_4P_En();                                 //灯光信号结束
 950   1        EA = 1;                                       //重启中断
 951   1        if(sb_LedCot == b_LedLength){ //函数调用次数超过灯光长度值0，灯光效果重新开始
 952   2          sb_LedCot = 0;//最大值-1 因为开始值是0
 953   2        }
 954   1        else sb_LedCot ++;//函数被调用一次加1
 955   1      }
 956          /*
 957          void WS2811_blood_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F)
 958          参数：
 959              b_LedLength:灯光效果的总长
 960              b_DarkLength:灯光效果中黑暗部分占的长度
 961              pdw_ColourStyle::亮灯效果
 962          */
 963          
 964          void WS2811_blood_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F){//顺序点亮
 965   1        static u8 xdata sb_LedCot = 0;
 966   1        u8 xdata b_Cot = 0;
 967   1        u8 xdata b_LedAddr = 0;
 968   1        if((*b_Reset_F) == 1){
 969   2          (*b_Reset_F) = 0;
 970   2          sb_LedCot = 0;        
 971   2        }
 972   1        EA = 0;                                 //锁住中断，防止中断打乱灯光信号数据发送
 973   1        b_LedLength=b_LedLength-b_DarkLength;//计算亮灯数
 974   1          for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){//循环亮参数颜色长度次
 975   2            b_LedAddr = 1 + b_Cot;                //灯的位置
 976   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度，如果大于数组长度，回到数组头
 977   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
 978   3            }
 979   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//赋值灯
 980   2        }
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 17  

 981   1        for(b_Cot = 0; b_Cot < b_DarkLength; b_Cot++){//循环黑暗灯次
 982   2            b_LedAddr = 1 + b_Cot;
 983   2            if(b_LedAddr > (u8)(*gpdw_dark)){//数组首个是长度，如果大于数组长度，回到数组头
 984   3                b_LedAddr -= (u8)(*gpdw_dark);
 985   3            }
 986   2            WS2811_4P_1Led(2, *(gpdw_dark + b_LedAddr));
 987   2            
 988   2        }
 989   1        WS2811_4P_En();           //灯光信号结束
 990   1        EA = 1;                   //重启中断
 991   1      //  if(sb_LedCot == b_LedLength){
 992   1      //    sb_LedCot = 0;//最大值-1 因为开始值是0
 993   1      //  }
 994   1      //  else sb_LedCot ++;
 995   1      }
 996          
 997          /*参数：
 998          void WS2811_blood_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F)
 999          
1000              b_LedLength:灯光效果的总长
1001              b_DarkLength:灯光效果中黑暗部分占的长度
1002              pdw_ColourStyle::亮灯效果
1003          */
1004          
1005          void WS2811_blood1_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F){//顺序点亮
1006   1        static u8 xdata sb_LedCot = 0;
1007   1        u8 xdata b_Cot = 0;
1008   1        u8 xdata b_LedAddr = 0;
1009   1        if((*b_Reset_F) == 1){
1010   2          (*b_Reset_F) = 0;
1011   2          sb_LedCot = 0;        
1012   2        }
1013   1        EA = 0;                                 //锁住中断，防止中断打乱灯光信号数据发送
1014   1        b_LedLength=b_LedLength-b_DarkLength;//计算亮灯数
1015   1          for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){//循环亮参数颜色长度次
1016   2            b_LedAddr = 1 + b_Cot;                //灯的位置
1017   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度，如果大于数组长度，回到数组头
1018   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
1019   3            }
1020   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//赋值灯
1021   2        }
1022   1        for(b_Cot = 0; b_Cot < b_DarkLength; b_Cot++){//循环黑暗灯次
1023   2            b_LedAddr = 1 + b_Cot;
1024   2            if(b_LedAddr > (u8)(*gpdw_White_low)){//数组首个是长度，如果大于数组长度，回到数组头
1025   3                b_LedAddr -= (u8)(*gpdw_White_low);
1026   3            }
1027   2            WS2811_4P_1Led(2, *(gpdw_White_low + b_LedAddr));
1028   2            
1029   2        }
1030   1        WS2811_4P_En();           //灯光信号结束
1031   1        EA = 1;                   //重启中断
1032   1      //  if(sb_LedCot == b_LedLength){
1033   1      //    sb_LedCot = 0;//最大值-1 因为开始值是0
1034   1      //  }
1035   1      //  else sb_LedCot ++;
1036   1      }
1037          
1038          /*
1039          void WS2811_shuiliu_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F)
1040          参数：
1041              b_LedLength:灯光效果的总长
1042              b_DarkLength:灯光效果中黑暗部分占的长度
C51 COMPILER V9.59.0.0   LED                                                               08/26/2025 17:58:26 PAGE 18  

1043              pdw_ColourStyle::亮灯效果
1044          */
1045          
1046          void WS2811_shuiliu_P4(u8 b_LedLength, u8 b_DarkLength,u32 *pdw_ColourStyle, u8 *b_Reset_F){//顺序点亮
1047   1        static u8 xdata sb_LedCot = 0;
1048   1        u8 xdata b_Cot = 0;
1049   1        u8 xdata b_LedAddr = 0;
1050   1        if((*b_Reset_F) == 1){
1051   2          (*b_Reset_F) = 0;
1052   2          sb_LedCot = 0;        
1053   2        }
1054   1        EA = 0;                                 //锁住中断，防止中断打乱灯光信号数据发送
1055   1        b_LedLength=b_LedLength-b_DarkLength;//计算亮灯数
1056   1          for(b_Cot = 0; b_Cot < b_LedLength; b_Cot++){//循环亮参数颜色长度次
1057   2            b_LedAddr = 1 + b_Cot;                //灯的位置
1058   2            if(b_LedAddr > (u8)(*pdw_ColourStyle)){//数组首个是长度，如果大于数组长度，回到数组头
1059   3                b_LedAddr -= (u8)(*pdw_ColourStyle);
1060   3            }
1061   2            WS2811_4P_1Led(2, *(pdw_ColourStyle + b_LedAddr));//赋值灯
1062   2        }
1063   1        for(b_Cot = 0; b_Cot < b_DarkLength; b_Cot++){//循环黑暗灯次
1064   2            b_LedAddr = 1 + b_Cot;
1065   2            if(b_LedAddr > (u8)(*gpdw_dark)){//数组首个是长度，如果大于数组长度，回到数组头
1066   3                b_LedAddr -= (u8)(*gpdw_dark);
1067   3            }
1068   2            WS2811_4P_1Led(2, *(gpdw_dark + b_LedAddr));
1069   2            
1070   2        }
1071   1        WS2811_4P_En();           //灯光信号结束
1072   1        EA = 1;                   //重启中断
1073   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4251    ----
   CONSTANT SIZE    =   1596    ----
   XDATA SIZE       =     33     192
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
